# 一条sql更新语句如何执行

之前流程和查询流程一样，不同的是，更新流程涉及到日志模块，redo log和binlog

## redo log

《孔乙己》里的酒店掌柜有个粉板，用来记录客人的赊账记录，若赊账人不多，把顾客名目记在板上，若赊账人多了，则记在账本上。

用粉板的原因就是账本查找太麻烦了，先记在粉板上，等空闲了在记在账本里。

这样的技术过程在mysql里就是经常说到的WAL技术，write-ahead logging，先写日志，等不忙的时候在写sql。

具体说，innodb会把记录写到redo log，并更新内存，适当的时候写入磁盘。

与粉板类似，redo log的大小是固定的，一般是用的环形结构，write pos是当前记录的位置，边写边后移，check point是擦除的点指向，也是后移，擦除前把数据写入磁盘。redo log可以理解为一个环形队列。

有了redo log就能保证，即使数据库发生异常重启，之前提交的记录不会丢失，这个被称为crash-safe。

### binlog

redo log是InnoDB特有的日志，而server层有个日志，称为binlog。

最早没有InnoDB引擎，binlog只能用于归档，无法用于crash-safe。

这两种日志的三个大的区别：

1.  redo log是innodb独有的，bin log是server层实现的，故所有引擎都可使用。

2.  redo log是物理日志，记录的是“在某个数据页做了什么修改”，binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给id=2这行的c字段+1”。

3.  redo log是循环写的，空间固定会用完，binlog可以追加写入，不会覆盖以前的日志。

### 具体执行

1.  执行器先找引擎取 id = 2 的这一行，因为id是主键，直接用树搜索到这一行。如果行数据在内存里，直接返回给执行器，否则，需要先从磁盘读入内存，在返回。

2.  执行器拿到引擎给的行数据，把这个值+1，得到新的行数据，在调用引擎写入新行数据。

3.  引擎将这行新数据写入内存，同时将操作记录到redo log，此时redo log处于prepare状态，告知执行器执行完成，可以提交事务。

4.  执行器生成这个操作的binlog，写入磁盘。

5.  执行器调用引擎的事务接口，引擎把写入的redo log改成提交（commit）状态，更新完成。

最后三步有点绕，将redo log拆成了两个步骤，preapre和commit，这就是两阶段提交。

### 两阶段提交

目的在于保持两份日志的逻辑一致。

当需要恢复到指定的某一秒时，比如某天下午两点发现中午十二点有一次误删表，需要找回数据，那你可以这么做：

+ 首先，找到最近的一次全量备份，如果你运气好，可能就是昨天晚上的一个备份，从这个备份恢复到临时库；
+ 然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到中午误删表之前的那个时刻。

由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。仍然用前面的 update 语句来做例子。假设当前 ID=2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？

1. 先写 redo log 后写 binlog。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。

2. 先写 binlog 后写 redo log。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。

### 数据库扩容

1. 停机扩容方案，这是一种很多人初期都会使用的方案。
    1. 小明先挂公告，告诉大家明天的凌晨02：00 - 06：00，站点将停机升级；
    2. 时间到了，小明停止了所有对外服务；
    3. 小明新增了2个数据库，然后写了一个程序，将原先的2个库的数据迁移到现有的4个库（2+2）上；
    4. 数据迁移完成，修改数据库服务配置；
    5. 重启服务，并重新开启对外服务。

    回滚方案：
        数据迁移失败，或者迁移后测试失败，则将服务配置修改回原先的两个库，改天再升级。
    优点：
        简单
    缺点：
        不高可用
        开启升级到升级完成，时间短，项目组压力大，易出错
        升级时间基本是半夜人流量最少的时候，项目组疲累，容易出错
        运行一段时间后，发现问题，难以回滚，只能回到扩容前，会丢失部分数据
    适用：
        小型网站；
        大部分游戏；
        对高可用要求不高的服务。

2. 平滑扩容
    现在我们来聊一下本文的重点：平滑扩容中最好的方案就是扩容的数据库是原先数据库的倍数，如：2个数据库扩容到4个数据库，是原先的2倍。步骤：

    （1）新增2个数据库

    （2）配置双主进行数据同步（先测试，后线上，重启服务时间是秒级）

    （3）数据同步完成之后，配置主主双写（因为同步有延迟，如果每时每刻都有数据写入/更新的话，就不能准确的保证数据已经同步完成）

    （4）数据同步完成后（时间比较长），删除双主同步，修改数据库配置，并重启（秒级）；

    （5）此时已经扩容完成，但此时的数据并没有减少，新增的数据库跟旧的数据库一样多的数据，此时还需要写一个程序，清空数据库中多余的数据，如：

        1.User1去除 uid % 4 = 2的数据；
        2.User3去除 uid % 4 = 0的数据；
        3.User2去除 uid % 4 = 3的数据；
        4.User4去除 uid % 4 = 1的数据。
        现在，我们就已经完成了数据库的平滑扩容了。

        优点
            扩容期间，服务照常进行，保证高可用；
            时间长，项目组压力没有这么大，出错率低；
            扩容期间，遇到什么问题，都可以随时调试，不怕影响线上服务；
            每个数据库少了一半的数据量。

        缺点
            程序复杂，需要配置双主、主主双写、检测数据同步等额外技术；
            但后期数据库成千上万台的时候，扩容复杂（情况非常少，除非将很多业务数据放在同一个数据库）。
        适用：
            大型网站；
            对高可用要求高的服务。