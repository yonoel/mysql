# 一条sql查询语句如何执行

```sql
select * from T where id = 10;
```

mysql分为server层和存储引擎两部分。

## server层

包括连接器，查询缓存，分析器，优化器，执行器等，涵盖了大多数mysql的核心功能服务，以及所有
内置函数，所有跨存储引擎的功能都在这一层实现，比如存储过程，触发器，视图等。

## 存储引擎层

存储引擎负责数据的存储和提取，其架构模式是插件式的，支持多种存储引擎。

## 连接器

连接器负责跟客户端建立链接，获取权限，维持和管理链接。比如链接命令：

```sql
mysql -h$ip -P$port -u$user -p
```

+   如果用户名或密码不对，收到“Access denied for user”

+   如果认证通过，连接器会到权限表里查询你拥有的权限，之后这个链接里面的权限逻辑，都将依赖于此时读取的权限。

链接完成后，没有后续动作，链接就处于空闲状态，可以在 "show processlist"观察到它。

连接器会自动断开太长时间没有动作的链接，由wait_timeout控制，默认8h。

若断开后，客户端在发送请求，收到错误提醒 "lose connection to MySQL sever during query"。

数据库里的长链接是指链接成功后，若客户端持续有请求，则一直用同一个链接，端链接是指每次执行完
很少的几次查询就断开链接，下次查询在重新建立一个链接。

建立链接的过程比较复杂，开发中少建立链接，使用长链接。

但长链接使用太多，mysql内存过大。有以下两种方案：

1.  定期断开长链接。

2.  如果是5.7及以后版本，每次执行完一个比较大的操作，通过执行mysql_reset_connection来初始化链接资源，不需要重连和校验权限，但是会将链接恢复到刚刚创建完成时的状态。

### 查询缓存

链接建立的第二步完成，先查询缓存，之前执行过的语句和结果以key-value对保存在内存中。

大多数情况下，不推荐使用查询缓存。
因为查询缓存失效非常频繁，只要有对一个表的更新，这个表上的所有缓存被清空。
除非这张表是张静态表，比如系统配置表，适合查询查询缓存。

将参数"query_cache_type"设置为"demand"，对于默认的sql语句不使用缓存，对于确定要使用查询缓存的语句可以用sql_cache 显式指定。

```sql
select SQL_CACHE * FROM T where id = 10;
```

mysql8.0以后就没有查询缓存的功能了。

### 分析器

若没有命中缓存，则执行分析语句。

先做词法分析，把你输入的select关键字识别出来，把T识别为表名，把字符串id识别为"列id"。

第二步分析语法，语法分析器根据语法规则，判断你输入的sql是否符合语法。如果语句不对，则返回“you hava an error in your sql syntax”。一般语法错误会提示第一个出现错误的位置，所以你要关注的是“use near”紧接的内容。

### 优化器

经过分析器，则进入优化器，优化器是在表里面有多个索引，决定使用哪个索引；或者在多表查询时决定各个表的链接顺序。

### 执行器

经过优化器知道怎么做以后，就进入执行器，执行前先判断有没有权限，没有则返回错误，即使是查询缓存，返回结果时也做权限验证。

有权限则执行语句，开表，使用存储引擎提供的接口。重复判断每一行。

数据库的慢查询日志里有个rows_examined字段，描述这句sql扫描了多少行，有些场景下，执行器调用一次，引擎内部扫描多行，故引擎扫描行数跟rows_examined不一定完全一致。


