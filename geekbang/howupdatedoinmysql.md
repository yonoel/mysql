# 一条sql更新语句如何执行

之前流程和查询流程一样，不同的是，更新流程涉及到日志模块，redo log和binlog

## redo log

《孔乙己》里的酒店掌柜有个粉板，用来记录客人的赊账记录，若赊账人不多，把顾客名目记在板上，若赊账人多了，则记在账本上。

用粉板的原因就是账本查找太麻烦了，先记在粉板上，等空闲了在记在账本里。

这样的技术过程在mysql里就是经常说到的WAL技术，write-ahead logging，先写日志，等不忙的时候在写sql。

具体说，innodb会把记录写到redo log，并更新内存，适当的时候写入磁盘。

与粉板类似，redo log的大小是固定的，一般是用的环形结构，write pos是当前记录的位置，边写边后移，check point是擦除的点指向，也是后移，擦除前把数据写入磁盘。

有了redo log就能保证，即使数据库发生异常重启，之前提交的记录不会丢失，这个被称为crash-safe。

### binlog

redo log是InnoDB特有的日志，而server层有个日志，称为binlog。

最早没有InnoDB引擎，binlog只能用于归档，无法用于crash-safe。

这两种日志的区别：

1.  redo log是innodb独有的，bin log是server层实现的，故所有引擎都可使用。

2.  redo log是物理日志，记录的是“在某个数据页做了什么修改”，binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给id=2这行的c字段+1”。

3.  redo log是循环写的，空间固定会用完，binlog可以追加写入，不会覆盖以前的日志。

### 具体执行

1.  执行器先找引擎取 id = 2 的这一行，因为id是主键，直接用树搜索到这一行。如果行数据在内存里，直接返回给执行器，否则，需要先从磁盘读入内存，在返回。

2.  执行器拿到引擎给的行数据，把这个值+1，得到新的行数据，在调用引擎写入新行数据。

3.  引擎将这行新数据写入内存，同时将操作记录到redo log，此时redo log处于prepare状态，告知执行器执行完成，可以提交事务。

4.  执行器生成这个操作的binlog，写入磁盘。

5.  执行器调用引擎的事务接口，引擎把写入的redo log改成提交（commit）状态，更新完成。

最后三步有点绕，将redo log拆成了两个步骤，preapre和commit，这就是两阶段提交。

### 两阶段提交

目的在于保持两份日志的逻辑一致。